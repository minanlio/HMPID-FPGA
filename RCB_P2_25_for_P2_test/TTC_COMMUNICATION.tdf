--  
-- COMMUNICATION WITH TTCRx
--

-- M. Minervini (lazzaro.manlio.minervini@cern.ch)
-- 06/10/2014


SUBDESIGN TTC_COMMUNICATION
(
	-- INPUT
		CLOCK: INPUT; 
		RESETn: INPUT;
		-- TTCRx
		DQ[3..0]: INPUT; 
		DOUTSTR:INPUT;
		ADDRESS[3..0]: INPUT; 
		DATA_IN[11..0]: INPUT; 
		BCNT[11..0]: INPUT; 
		BCNTSTR: INPUT; 
		L1A: INPUT; -- trigger L1
		L0: INPUT; -- trigger L0
		-- ddlctrlr
		RST_SEQ_ERR_FLAG: INPUT; 				
		L1A_LATENCY_EXT[7..0]: INPUT; 
		ERROR_BIT_ENA: INPUT;
		
	-- OUTPUT
		-- ddlctrlr
		L2_PULSE: OUTPUT; 
		SEQ_ERR_FLAG: OUTPUT;
		-- header
		WORD0[31..0]: OUTPUT;
		WORD1[31..0]: OUTPUT;
		WORD2[31..0]: OUTPUT;
		WORD3[31..0]: OUTPUT;
		WORD4[31..0]: OUTPUT;
		WORD5[31..0]: OUTPUT;
		WORD6[31..0]: OUTPUT;
		WORD7[31..0]: OUTPUT;
		WORD8[31..0]: OUTPUT;
		WORD9[31..0]: OUTPUT;
		ERROR_BIT[15..0]: OUTPUT; 
		-- BUSY
		TTC_COM_RST: OUTPUT; 
		
		DEC_STATE[7..0]: OUTPUT;
		CTRL_STATE[7..0]: OUTPUT;
		
)

variable

-----------------------------------------------------------
-- REGISTERS
-----------------------------------------------------------

-- DECODER_SM FLIP FLOP --
L1_TRIG_MESSAGE[7..0]: DFFE;
BUNCH_CROSSING[11..0]: DFFE;
EVENT_ID_1[11..0]: DFFE;
EVENT_ID_2_HIGH[11..0]: DFFE;
EVENT_ID_2_LOW[11..0]: DFFE;
TRIGGER_CLASSES_A[11..0]: DFFE;
TRIGGER_CLASSES_B[11..0]: DFFE;
TRIGGER_CLASSES_C[11..0]: DFFE;
TRIGGER_CLASSES_D[11..0]: DFFE;
TRIGGER_CLASSES_E[11..0]: DFFE;
TRIGGER_CLASSES_F[11..0]: DFFE;
TRIGGER_CLASSES_G[11..0]: DFFE;
TRIGGER_CLASSES_H[11..0]: DFFE;
TRIGGER_CLASSES_I[3..0]: DFFE;
L2_SOFT_TRIG: DFFE;
L2_DETECTOR_A[7..0]: DFFE;
L2_DETECTOR_B[11..0]: DFFE;
L2_DETECTOR_C[3..0]: DFFE;
SEND_L2: SRFF;


-- SEQ_CONTROLLER_SM FLIP FLOP --
L0_FLAG: SRFF;
L1_FLAG: SRFF;
L2a_FLAG: SRFF;
L2r_FLAG: SRFF;
L0_FLAG_DELAY1: DFF;
L0_FLAG_DELAY2: DFF;
L0_FLAG_DELAY3: DFF;
L0_FLAG_DELAY4: DFF;
L0_FLAG_DELAY5: DFF;
L1_TIME_COUNTER[8..0]: DFFE;
L2_TIMEOUT_COUNTER[16..0]: DFFE;
ERROR_BIT_0: SRFF;
ERROR_BIT_1: SRFF;
ERROR_BIT_9: SRFF;
ERROR_BIT_10: SRFF;
ERROR_BIT_13: SRFF;
SEQ_ERR_FLAG: SRFF;


-----------------------------------------------------------
-- NODES
-----------------------------------------------------------

-- DECODER_SM NODE --
ENA_L1_TRIG_MESSAGE: NODE;
ENA_EVENT_ID_1: NODE;
ENA_EVENT_ID_2_HIGH: NODE;
ENA_EVENT_ID_2_LOW: NODE;
ENA_TRIGGER_CLASSES_A: NODE;
ENA_TRIGGER_CLASSES_B: NODE;
ENA_TRIGGER_CLASSES_C: NODE;
ENA_TRIGGER_CLASSES_D: NODE;
ENA_TRIGGER_CLASSES_E: NODE;
ENA_TRIGGER_CLASSES_F: NODE;
ENA_TRIGGER_CLASSES_G: NODE;
ENA_TRIGGER_CLASSES_H: NODE;
ENA_TRIGGER_CLASSES_I: NODE;
ENA_L2_SOFT_TRIG: NODE;
RESET_FOR_SOFT_TRIG: NODE;
RESET_FOR_REAL_TRIG: NODE;
ENA_L2_DETECTOR_A: NODE;
ENA_L2_DETECTOR_B: NODE; 
ENA_L2_DETECTOR_C: NODE;
L2a_INTERNAL: NODE;
L2r_INTERNAL: NODE;
SET_SEND_L2: NODE;


-- SEQ_CONTROLLER_SM NODE --
ENA_L1_TIME_COUNTER: NODE;
CLRN_L1_TIME_COUNTER: NODE;
ENA_L2_TIMEOUT_COUNTER: NODE;
CLRN_L2_TIMEOUT_COUNTER: NODE;
SET_ERROR_BIT_1: NODE;
SET_ERROR_BIT_9: NODE;
SET_ERROR_BIT_10: NODE;
SET_ERROR_BIT_13: NODE;
RESET_FLAG: NODE;
RES_SEND_L2: NODE;
SET_SEQ_ERR_FLAG: NODE; 

STATUS_ERROR_BIT[15..0]: NODE;
L2_FLAG: NODE;
L1A_LATENCY[8..0]: NODE;


------------------------------------------------------------
-- STATE MACHINES
------------------------------------------------------------

DECODER_SM: MACHINE WITH STATES (

				IDLE_DECODER,					
				L1_HEADER,					
				L2a_HEADER,					
				L2a_WORD2,					
				L2a_WORD2_WAIT,				
				L2a_WORD3,					
				L2a_WORD3_WAIT,				
				L2a_WORD4,					
				L2a_WORD4_WAIT,				
				L2a_WORD5,					
				L2a_WORD5_WAIT,				
				L2a_WORD6,					
				L2a_WORD6_WAIT,				
				L2a_WORD7,					
				L2a_WORD7_WAIT,				
				L2a_WORD8,					
				L2a_WORD8_WAIT,	
				L2a_WORD9,					--20
				L2a_WORD9_WAIT,				--21
				L2a_WORD10,					--22
				L2a_WORD10_WAIT,				--23
				L2a_WORD11,					--24
				L2a_WORD11_WAIT,				--25
				L2a_WORD12,					--26
				L2a_WORD12_WAIT,				--27
				L2a_WORD13,					--28
				L2a_WORD13_WAIT,				--29
				TRIGGER_DISCRIMINATION,		
				L2r_HEADER_1,				
				L2r_HEADER_2				
			);
				
SEQ_CONTROLLER_SM: MACHINE WITH STATES (

				IDLE_SEQ_CONTROLLER,	
				L1_WAITING,				
				L1_TIME_VIOLATION,		
				L1_TIMEOUT_REJECT_1,	
				L1_TIMEOUT_REJECT_2,	
				L1_MISSING,				
				L2_WAITING,				
				L2a_SEND_1,				
				L2a_SEND_1a,			
				L2a_SEND_2,				
				L2a_SEND_3,				
				L2r_SEND_1,				
				L2r_SEND_2,				
				L2r_SEND_3,				
				L2r_SEND_2a,			
				L2r_SEND_3a,			
				L2r_SEND_4a,			
				L2_TIMEOUT_VIOLATION,
				L2_MISSING_1,			
				L2_MISSING_2,			
				L2_MISSING_3,			
				L0_MISSING,				
				L0_L1_MISSING			
		);
			
			
BEGIN		

DEFAULTS

-- DEFAULT VALUE FOR DECODER_SM NODE --
ENA_L1_TRIG_MESSAGE = GND;
ENA_EVENT_ID_1 = GND;
ENA_EVENT_ID_2_HIGH = GND;
ENA_EVENT_ID_2_LOW = GND;
ENA_TRIGGER_CLASSES_A = GND;
ENA_TRIGGER_CLASSES_B = GND;
ENA_TRIGGER_CLASSES_C = GND;
ENA_TRIGGER_CLASSES_D = GND;
ENA_TRIGGER_CLASSES_E = GND;
ENA_TRIGGER_CLASSES_F = GND;
ENA_TRIGGER_CLASSES_G = GND;
ENA_TRIGGER_CLASSES_H = GND;
ENA_TRIGGER_CLASSES_I = GND;
ENA_L2_SOFT_TRIG = GND;
RESET_FOR_SOFT_TRIG = GND;
RESET_FOR_REAL_TRIG = GND;
ENA_L2_DETECTOR_A = GND;
ENA_L2_DETECTOR_B = GND; 
L2a_INTERNAL = GND;
L2r_INTERNAL = GND;
SET_SEND_L2 = GND;
	
-- DEFAULT VALUE FOR SEQ_CONTROLLER_SM --
ENA_L1_TIME_COUNTER = GND;
CLRN_L1_TIME_COUNTER = VCC;
ENA_L2_TIMEOUT_COUNTER = GND;
CLRN_L2_TIMEOUT_COUNTER = VCC;
SET_ERROR_BIT_9 = GND;
SET_ERROR_BIT_10 = GND;
SET_ERROR_BIT_13 = GND;
SET_ERROR_BIT_1 = GND;
RESET_FLAG = GND;
RES_SEND_L2 = GND;
TTC_COM_RST = GND;
SET_SEQ_ERR_FLAG = GND;
L2_PULSE = GND;
	
END DEFAULTS;

-- FLIP FLOP DEFINITION FOR DECODER_SM --

L1_TRIG_MESSAGE[7..0].d = DATA_IN[11..4]; -- memorizza i bit utili dell'L1 message
L1_TRIG_MESSAGE[7..0].clk = CLOCK;
L1_TRIG_MESSAGE[7..0].ena = ENA_L1_TRIG_MESSAGE;
L1_TRIG_MESSAGE[7..0].clrn = RESETn;

BUNCH_CROSSING[11..0].d = BCNT[11..0]; -- memorizza il valore di BCNT[11..0] relativo al bunch crossing
BUNCH_CROSSING[11..0].clk = CLOCK; --  immediatamente successivo ad un impulso di L1A 
BUNCH_CROSSING[11..0].ena = BCNTSTR;
BUNCH_CROSSING[11..0].clrn = RESETn;

EVENT_ID_1[11..0].d = DATA_IN[11..0]; -- memorizza i 12 bit della WORD 1 dell'L2 message, ovvero il BCID[11..0]
EVENT_ID_1[11..0].clk = CLOCK;   
EVENT_ID_1[11..0].ena = ENA_EVENT_ID_1;
EVENT_ID_1[11..0].clrn = RESETn;
 
EVENT_ID_2_HIGH[11..0].d = DATA_IN[11..0]; -- memorizza la parte alta (12 bit) dell'orbit number ovvero la WORD 2 di un L2 message
EVENT_ID_2_HIGH[11..0].clk = CLOCK;
EVENT_ID_2_HIGH[11..0].ena = ENA_EVENT_ID_2_HIGH;
EVENT_ID_2_HIGH[11..0].clrn = RESETn;

EVENT_ID_2_LOW[11..0].d = DATA_IN[11..0]; -- memorizza la parte bassa (12 bit) dell'orbit number ovvero la WORD 3 di un L2 message
EVENT_ID_2_LOW[11..0].clk = CLOCK;  
EVENT_ID_2_LOW[11..0].ena = ENA_EVENT_ID_2_LOW;
EVENT_ID_2_LOW[11..0].clrn = RESETn;

TRIGGER_CLASSES_A[11..0].d = DATA_IN[11..0]; -- memorizza i bit L2Class[100..89] della WORD 5 di un L2a_message
TRIGGER_CLASSES_A[11..0].clk = CLOCK; 
TRIGGER_CLASSES_A[11..0].ena = ENA_TRIGGER_CLASSES_A;
TRIGGER_CLASSES_A[11..0].clrn = RESETn;

TRIGGER_CLASSES_B[11..0].d = DATA_IN[11..0]; -- memorizza i bit L2Class[88..77] della WORD 6 di un L2a_message
TRIGGER_CLASSES_B[11..0].clk = CLOCK;  
TRIGGER_CLASSES_B[11..0].ena = ENA_TRIGGER_CLASSES_B;
TRIGGER_CLASSES_B[11..0].clrn = RESETn; 

TRIGGER_CLASSES_C[11..0].d = DATA_IN[11..0]; -- memorizza i bit L2_Class[76..65] della WORD 7 di un L2a_message
TRIGGER_CLASSES_C[11..0].clk = CLOCK;  
TRIGGER_CLASSES_C[11..0].ena = ENA_TRIGGER_CLASSES_C;
TRIGGER_CLASSES_C[11..0].clrn = RESETn;

TRIGGER_CLASSES_D[11..0].d = DATA_IN[11..0]; -- memorizza i bit L2Class[64..53] della WORD 8 di un L2a_message
TRIGGER_CLASSES_D[11..0].clk = CLOCK;  
TRIGGER_CLASSES_D[11..0].ena = ENA_TRIGGER_CLASSES_D;
TRIGGER_CLASSES_D[11..0].clrn = RESETn; 

TRIGGER_CLASSES_E[11..0].d = DATA_IN[11..0]; -- memorizza i bit L2Class[52..41] della WORD 9 di un L2a_message
TRIGGER_CLASSES_E[11..0].clk = CLOCK;  
TRIGGER_CLASSES_E[11..0].ena = ENA_TRIGGER_CLASSES_E;
TRIGGER_CLASSES_E[11..0].clrn = RESETn; 

TRIGGER_CLASSES_F[11..0].d = DATA_IN[11..0]; -- memorizza i bit L2Class[40..29] della WORD 10 di un L2a_message
TRIGGER_CLASSES_F[11..0].clk = CLOCK;  
TRIGGER_CLASSES_F[11..0].ena = ENA_TRIGGER_CLASSES_F;
TRIGGER_CLASSES_F[11..0].clrn = RESETn; -- AND !RESET_FOR_SOFT_TRIG;

TRIGGER_CLASSES_G[11..0].d = DATA_IN[11..0]; -- memorizza i bit L2Class[28..17] della WORD 11 di un L2a_message
TRIGGER_CLASSES_G[11..0].clk = CLOCK;  
TRIGGER_CLASSES_G[11..0].ena = ENA_TRIGGER_CLASSES_G;
TRIGGER_CLASSES_G[11..0].clrn = RESETn; -- AND !RESET_FOR_SOFT_TRIG;

TRIGGER_CLASSES_H[11..0].d = DATA_IN[11..0]; -- memorizza i bit L2Class[16..5] della WORD 12 di un L2a_message
TRIGGER_CLASSES_H[11..0].clk = CLOCK;  
TRIGGER_CLASSES_H[11..0].ena = ENA_TRIGGER_CLASSES_H;
TRIGGER_CLASSES_H[11..0].clrn = RESETn; -- AND !RESET_FOR_SOFT_TRIG;

TRIGGER_CLASSES_I[3..0].d = DATA_IN[11..8]; -- memorizza i bit L2Class[4..1] della WORD 13 di un L2a_message
TRIGGER_CLASSES_I[3..0].clk = CLOCK;  
TRIGGER_CLASSES_I[3..0].ena = ENA_TRIGGER_CLASSES_I;
TRIGGER_CLASSES_I[3..0].clrn = RESETn; -- AND !RESET_FOR_SOFT_TRIG;


L2_SOFT_TRIG.d = DATA_IN[8]; -- memorizza il Software Trigger bit della WORD 4 di un L2 message 
L2_SOFT_TRIG.clk = CLOCK;
L2_SOFT_TRIG.ena = ENA_L2_SOFT_TRIG;
L2_SOFT_TRIG.clrn = RESETn;

L2_DETECTOR_A[7..0].d = DATA_IN[7..0]; -- memorizza i bit L2Detector[24..17] (8 bit) della WORD 9 di un L2 message nel caso di Software Trigger
L2_DETECTOR_A[7..0].clk = CLOCK;  
L2_DETECTOR_A[7..0].ena = ENA_L2_DETECTOR_A;
L2_DETECTOR_A[7..0].clrn = RESETn AND !RESET_FOR_REAL_TRIG;

L2_DETECTOR_B[11..0].d = DATA_IN[11..0]; -- memorizza i bit L2Detector[16..5] (12 bit) della WORD 10 di un L2 message nel caso di Software Trigger
L2_DETECTOR_B[11..0].clk = CLOCK;  
L2_DETECTOR_B[11..0].ena = ENA_L2_DETECTOR_B;
L2_DETECTOR_B[11..0].clrn = RESETn AND !RESET_FOR_REAL_TRIG;

L2_DETECTOR_C[3..0].d = DATA_IN[11..8]; -- memorizza i bit L2Detector[4..1] (4 bit) della WORD 11 di un L2 message nel caso di Software Trigger
L2_DETECTOR_C[3..0].clk = CLOCK;  
L2_DETECTOR_C[3..0].ena = ENA_L2_DETECTOR_C;
L2_DETECTOR_C[3..0].clrn = RESETn AND !RESET_FOR_REAL_TRIG;

SEND_L2.s = SET_SEND_L2; -- la DECODER_SM indica alla SEQ_CONTROLLER_SM che ha terminato il processo di decodifica
SEND_L2.r = RES_SEND_L2;
SEND_L2.clk = CLOCK;
SEND_L2.clrn = RESETn;


STATUS_ERROR_BIT[15..0] = (ERROR_BIT_ENA & (B"00",ERROR_BIT_13,B"00",ERROR_BIT_10,ERROR_BIT_9,B"0000000", ERROR_BIT_1, ERROR_BIT_0));  
ERROR_BIT[15..0] = (B"00",ERROR_BIT_13,B"00",ERROR_BIT_10,ERROR_BIT_9,B"0000000", ERROR_BIT_1, ERROR_BIT_0);

WORD0[31..0] = H"FFFFFFFF";
WORD1[31..0] = (H"03", B"00", L1_TRIG_MESSAGE[7..0], B"00", EVENT_ID_1[11..0]);
WORD2[31..0] = (H"00", EVENT_ID_2_HIGH[11..0], EVENT_ID_2_LOW[11..0]);
WORD3[31..0] = (H"00", L2_DETECTOR_A[7..0], L2_DETECTOR_B[11..0], L2_DETECTOR_C[3..0]); -- UTILIZZATO IN L2 SOFTWARE TRIGGER
WORD4[31..0] = (H"0",STATUS_ERROR_BIT[15..0],BUNCH_CROSSING[11..0]); 
WORD5[31..0] = (TRIGGER_CLASSES_F[3..0], TRIGGER_CLASSES_G[11..0], TRIGGER_CLASSES_H[11..0], TRIGGER_CLASSES_I[3..0]);
WORD6[31..0] = (TRIGGER_CLASSES_D[11..0], TRIGGER_CLASSES_E[11..0], TRIGGER_CLASSES_F[11..4]);
WORD7[31..0] = (TRIGGER_CLASSES_A[7..0], TRIGGER_CLASSES_B[11..0], TRIGGER_CLASSES_C[11..0]);
WORD8[31..0] = (H"0", H"000000", TRIGGER_CLASSES_A[11..8]);
WORD9[31..0] = H"00000000";

DECODER_SM.clk = !CLOCK;
DECODER_SM.reset = !RESETn;


-- FLIP FLOP DEFINITION FOR SEQ_CONTROLLER_SM --
L0_FLAG.s = L0;
L0_FLAG.r = RESET_FLAG;
L0_FLAG.clk = !CLOCK;
L0_FLAG.clrn = RESETn; 

L1_FLAG.s = L1A;
L1_FLAG.r = RESET_FLAG;
L1_FLAG.clk = !CLOCK;
L1_FLAG.clrn = RESETn;

L2a_FLAG.s = L2a_INTERNAL;
L2a_FLAG.r = RESET_FLAG;
L2a_FLAG.clk = !CLOCK;
L2a_FLAG.clrn = RESETn;

L2r_FLAG.s = L2r_INTERNAL;
L2r_FLAG.r = RESET_FLAG;
L2r_FLAG.clk = !CLOCK;
L2r_FLAG.clrn = RESETn;

L0_FLAG_DELAY1.d = L0_FLAG;						-- ritardano il segnale L0_FLAG da inviare all' ERROR_BIT_0
L0_FLAG_DELAY1.clk = !CLOCK;				-- si tiene cos� conto della durata di un L0 (realisticamente  
L0_FLAG_DELAY1.clrn = RESETn AND !RESET_FLAG;	-- maggiore di un colpo di clock)

L0_FLAG_DELAY2.d = L0_FLAG_DELAY1;
L0_FLAG_DELAY2.clk = !CLOCK;
L0_FLAG_DELAY2.clrn = RESETn AND !RESET_FLAG;

L0_FLAG_DELAY3.d = L0_FLAG_DELAY2;
L0_FLAG_DELAY3.clk = !CLOCK;
L0_FLAG_DELAY3.clrn = RESETn AND !RESET_FLAG;

L0_FLAG_DELAY4.d = L0_FLAG_DELAY3;
L0_FLAG_DELAY4.clk = !CLOCK;
L0_FLAG_DELAY4.clrn = RESETn AND !RESET_FLAG;

L0_FLAG_DELAY5.d = L0_FLAG_DELAY4;
L0_FLAG_DELAY5.clk = !CLOCK;
L0_FLAG_DELAY5.clrn = RESETn AND !RESET_FLAG;


L1_TIME_COUNTER[8..0].d = L1_TIME_COUNTER[8..0] + 1;
L1_TIME_COUNTER[8..0].clk = !CLOCK;
L1_TIME_COUNTER[8..0].ena = ENA_L1_TIME_COUNTER;
L1_TIME_COUNTER[8..0].clrn = RESETn AND CLRN_L1_TIME_COUNTER;

L2_TIMEOUT_COUNTER[16..0].d = L2_TIMEOUT_COUNTER[16..0] + 1;
L2_TIMEOUT_COUNTER[16..0].clk = !CLOCK;
L2_TIMEOUT_COUNTER[16..0].ena = ENA_L2_TIMEOUT_COUNTER;
L2_TIMEOUT_COUNTER[16..0].clrn = RESETn AND CLRN_L2_TIMEOUT_COUNTER;


ERROR_BIT_0.s = L0 AND L0_FLAG_DELAY5 AND !(L1_FLAG OR L2_FLAG); -- indica l'arriva di un L0 mentre se ne sta processando un altro
ERROR_BIT_0.r = RST_SEQ_ERR_FLAG;							 
ERROR_BIT_0.clk = !CLOCK;
ERROR_BIT_0.clrn = RESETn;

ERROR_BIT_1.s = SET_ERROR_BIT_1; -- indica un L0 Missing ovvero L1 ricevuto senza alcun L0
ERROR_BIT_1.r = RST_SEQ_ERR_FLAG;
ERROR_BIT_1.clk = !CLOCK;
ERROR_BIT_1.clrn = RESETn;

ERROR_BIT_9.s = SET_ERROR_BIT_9; -- indica che L1A signal e' arrivato prima della latenza attesa
ERROR_BIT_9.r = RST_SEQ_ERR_FLAG;
ERROR_BIT_9.clk = !CLOCK;
ERROR_BIT_9.clrn = RESETn;

ERROR_BIT_10.s = SET_ERROR_BIT_10; -- indica che si e' verificato un L2 timeout (L2 arriva prima del tempo) o un L2 missing (non è affatto arrivato mentre L1 si)
ERROR_BIT_10.r = RST_SEQ_ERR_FLAG; 
ERROR_BIT_10.clk = !CLOCK;
ERROR_BIT_10.clrn = RESETn;

ERROR_BIT_13.s = SET_ERROR_BIT_13; -- indica un L1 Missing ovvero L2 ricevuto senza alcun L1
ERROR_BIT_13.r = RST_SEQ_ERR_FLAG;
ERROR_BIT_13.clk = !CLOCK;
ERROR_BIT_13.clrn = RESETn;

SEQ_ERR_FLAG.s = SET_SEQ_ERR_FLAG;
SEQ_ERR_FLAG.r = RST_SEQ_ERR_FLAG;
SEQ_ERR_FLAG.clk = !CLOCK;
SEQ_ERR_FLAG.clrn = RESETn;

L1A_LATENCY[8..0] = ((B"0",L1A_LATENCY_EXT[7..0]) + B"010000000");

SEQ_CONTROLLER_SM.clk = CLOCK;
SEQ_CONTROLLER_SM.reset = !RESETn;

L2_FLAG = L2a_FLAG OR L2r_FLAG;


------------------------------------------------
------------------------------------------------
-- DECODER STATE MACHINE
------------------------------------------------
------------------------------------------------

CASE DECODER_SM is 
				
	WHEN IDLE_DECODER => 
		DEC_STATE[7..0] = H"00";
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"1" THEN
			DECODER_SM = L1_HEADER; -- L1 message
		ELSIF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"3" THEN
			DECODER_SM = L2a_HEADER; -- L2a message e generazione L2 pulse
		ELSIF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"5" THEN
			DECODER_SM = L2r_HEADER_1; -- L2r message e reiezione dell'evento
		ELSE
			DECODER_SM = IDLE_DECODER; 
		END IF;
			
	WHEN L1_HEADER =>
		DEC_STATE[7..0] = H"01";
		ENA_L1_TRIG_MESSAGE = VCC;
		DECODER_SM = IDLE_DECODER;
	
	WHEN L2a_HEADER =>
		DEC_STATE[7..0] = H"02";
		ENA_EVENT_ID_1 = VCC;
		L2a_INTERNAL = VCC; -- genera un impulso interno che fa attivare L2a_FLAG
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD2;
		ELSE 
			DECODER_SM = L2a_WORD2_WAIT;
		END IF;
		
	WHEN L2a_WORD2 =>
		DEC_STATE[7..0] = H"03";
		ENA_EVENT_ID_1 = GND;
		L2a_INTERNAL = GND;
		ENA_EVENT_ID_2_HIGH = VCC;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD3;
		ELSE 
			DECODER_SM = L2a_WORD3_WAIT;
		END IF;
		
	WHEN L2a_WORD2_WAIT =>
		DEC_STATE[7..0] = H"04";
		ENA_EVENT_ID_1 = GND;
		L2a_INTERNAL = GND;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD2;
		ELSE 
			DECODER_SM = L2a_WORD2_WAIT;
		END IF;
		
	WHEN L2a_WORD3 =>
		DEC_STATE[7..0] = H"05";
		ENA_EVENT_ID_2_HIGH = GND;
		ENA_EVENT_ID_2_LOW = VCC;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD4;
		ELSE 
			DECODER_SM = L2a_WORD4_WAIT;
		END IF;
	
	WHEN L2a_WORD3_WAIT =>
		DEC_STATE[7..0] = H"06";
		ENA_EVENT_ID_2_HIGH = GND;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD3;
		ELSE 
			DECODER_SM = L2a_WORD3_WAIT;
		END IF;
	
	WHEN L2a_WORD4 =>
		DEC_STATE[7..0] = H"07";
		ENA_EVENT_ID_2_LOW = GND;
		ENA_L2_SOFT_TRIG = VCC;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD5;
		ELSE 
			DECODER_SM = L2a_WORD5_WAIT;
		END IF;
	
	WHEN L2a_WORD4_WAIT =>
		DEC_STATE[7..0] = H"08";
		ENA_EVENT_ID_2_LOW = GND;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD4;
		ELSE 
			DECODER_SM = L2a_WORD4_WAIT;
		END IF;
		
	WHEN L2a_WORD5 =>
		DEC_STATE[7..0] = H"09";
		ENA_TRIGGER_CLASSES_A = VCC;
		ENA_L2_SOFT_TRIG = GND;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD6;
		ELSE 
			DECODER_SM = L2a_WORD6_WAIT;
		END IF;
	
	WHEN L2a_WORD5_WAIT =>
		DEC_STATE[7..0] = H"0A";
		ENA_L2_SOFT_TRIG = GND;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD5;
		ELSE 
			DECODER_SM = L2a_WORD5_WAIT;
		END IF;
	
	WHEN L2a_WORD6 =>
		DEC_STATE[7..0] = H"0B";
		ENA_TRIGGER_CLASSES_A = GND;
		ENA_TRIGGER_CLASSES_B = VCC;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD7;
		ELSE 
			DECODER_SM = L2a_WORD7_WAIT;
		END IF;
	
	WHEN L2a_WORD6_WAIT =>
		DEC_STATE[7..0] = H"0C";
		ENA_TRIGGER_CLASSES_A = GND;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD6;
		ELSE 
			DECODER_SM = L2a_WORD6_WAIT;
		END IF;
		
	WHEN L2a_WORD7 =>
		DEC_STATE[7..0] = H"0D";
		ENA_TRIGGER_CLASSES_B = GND;
		ENA_TRIGGER_CLASSES_C = VCC;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD8;
		ELSE 
			DECODER_SM = L2a_WORD8_WAIT;
		END IF;
	
	WHEN L2a_WORD7_WAIT =>
		DEC_STATE[7..0] = H"0E";
		ENA_TRIGGER_CLASSES_B = GND;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD7;
		ELSE 
			DECODER_SM = L2a_WORD7_WAIT;
		END IF;
		
	WHEN L2a_WORD8 =>
		DEC_STATE[7..0] = H"0F";
		ENA_TRIGGER_CLASSES_C = GND;
		ENA_TRIGGER_CLASSES_D = VCC;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD9;
		ELSE 
			DECODER_SM = L2a_WORD9_WAIT;
		END IF;
	
	WHEN L2a_WORD8_WAIT =>
		DEC_STATE[7..0] = H"10";
		ENA_TRIGGER_CLASSES_C = GND;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD8;
		ELSE 
			DECODER_SM = L2a_WORD8_WAIT;
		END IF;
		
	WHEN L2a_WORD9 =>
		DEC_STATE[7..0] = H"11";
		ENA_TRIGGER_CLASSES_D = GND;
		ENA_TRIGGER_CLASSES_E = VCC;
		ENA_L2_DETECTOR_A = VCC;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD10;
		ELSE 
			DECODER_SM = L2a_WORD10_WAIT;
		END IF;
	
	WHEN L2a_WORD9_WAIT =>
		DEC_STATE[7..0] = H"12";
		ENA_TRIGGER_CLASSES_D = GND;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD9;
		ELSE 
			DECODER_SM = L2a_WORD9_WAIT;
		END IF;
		
	WHEN L2a_WORD10 =>
		DEC_STATE[7..0] = H"13";
		ENA_TRIGGER_CLASSES_E = GND;
		ENA_TRIGGER_CLASSES_F = VCC;
		ENA_L2_DETECTOR_A = GND;
		ENA_L2_DETECTOR_B = VCC;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD11;
		ELSE 
			DECODER_SM = L2a_WORD11_WAIT;
		END IF;
	
	WHEN L2a_WORD10_WAIT =>
		DEC_STATE[7..0] = H"14";
		ENA_TRIGGER_CLASSES_E = GND;
		ENA_L2_DETECTOR_A = GND;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD10;
		ELSE 
			DECODER_SM = L2a_WORD10_WAIT;
		END IF;
		
	WHEN L2a_WORD11 =>
		DEC_STATE[7..0] = H"15";
		ENA_TRIGGER_CLASSES_F = GND;
		ENA_TRIGGER_CLASSES_G = VCC;
		ENA_L2_DETECTOR_B = GND;
		ENA_L2_DETECTOR_C = VCC;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD12;
		ELSE 
			DECODER_SM = L2a_WORD12_WAIT;
		END IF;
	
	WHEN L2a_WORD11_WAIT =>
		DEC_STATE[7..0] = H"16";
		ENA_TRIGGER_CLASSES_F = GND;
		ENA_L2_DETECTOR_B = GND;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD11;
		ELSE 
			DECODER_SM = L2a_WORD11_WAIT;
		END IF;
		
	WHEN L2a_WORD12 =>
		DEC_STATE[7..0] = H"17";
		ENA_TRIGGER_CLASSES_G = GND;
		ENA_TRIGGER_CLASSES_H = VCC;
		ENA_L2_DETECTOR_C = GND;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD13;
		ELSE 
			DECODER_SM = L2a_WORD13_WAIT;
		END IF;
	
	WHEN L2a_WORD12_WAIT =>
		DEC_STATE[7..0] = H"18";
		ENA_TRIGGER_CLASSES_G = GND;
		ENA_L2_DETECTOR_C = GND;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD12;
		ELSE 
			DECODER_SM = L2a_WORD12_WAIT;
		END IF;
		
	WHEN L2a_WORD13 =>
		DEC_STATE[7..0] = H"19";
		ENA_TRIGGER_CLASSES_H = GND;
		ENA_TRIGGER_CLASSES_I = VCC;
		DECODER_SM = TRIGGER_DISCRIMINATION;
	
	WHEN L2a_WORD13_WAIT =>
		DEC_STATE[7..0] = H"1A";
		ENA_TRIGGER_CLASSES_I = GND;
		IF DQ[3..0] == H"0" AND DOUTSTR AND ADDRESS[3..0] == H"4" THEN
			DECODER_SM = L2a_WORD13;
		ELSE 
			DECODER_SM = L2a_WORD13_WAIT;
		END IF;
		
	WHEN TRIGGER_DISCRIMINATION =>
		DEC_STATE[7..0] = H"1B";
		ENA_TRIGGER_CLASSES_E = GND;
		SET_SEND_L2 = VCC; -- setta il FLAG SEND_L2: la SEQ_CONTROLLER_SM puo' eventualmente generare L2 interno per invio dati
		IF L2_SOFT_TRIG THEN 
			RESET_FOR_SOFT_TRIG = VCC;
		ELSE
			RESET_FOR_REAL_TRIG = VCC;
		END IF;
		DECODER_SM = IDLE_DECODER;
	
	WHEN L2r_HEADER_1 =>
		DEC_STATE[7..0] = H"1C";
		L2r_INTERNAL = VCC;
		DECODER_SM = L2r_HEADER_2;
		
	WHEN L2r_HEADER_2 =>
		DEC_STATE[7..0] = H"1D";
		L2r_INTERNAL = GND;
		DECODER_SM = IDLE_DECODER;	
		
	WHEN OTHERS =>
		DECODER_SM = IDLE_DECODER;
		
	END CASE;

	
------------------------------------------------	
------------------------------------------------
-- SEQ_CONTROLLER STATE MACHINE
------------------------------------------------
------------------------------------------------

CASE SEQ_CONTROLLER_SM is 

	WHEN IDLE_SEQ_CONTROLLER => 
		CTRL_STATE[7..0] = H"00";
		IF L0_FLAG AND !L1_FLAG AND !L2_FLAG THEN -- arriva un L0 e parte una normale acquisizione
			SEQ_CONTROLLER_SM = L1_WAITING; 
		ELSIF !L0_FLAG AND L1_FLAG AND !L2_FLAG THEN -- arriva L1 senza un precedente L0
			SEQ_CONTROLLER_SM = L0_MISSING;
		ELSIF !L0_FLAG AND !L1_FLAG AND L2_FLAG THEN -- arriva L2a o L2r senza alcun L1 e L0 precedenti
			SEQ_CONTROLLER_SM = L0_L1_MISSING;
		ELSE
			SEQ_CONTROLLER_SM = IDLE_SEQ_CONTROLLER; 
		END IF;
		
	WHEN L1_WAITING => 
		CTRL_STATE[7..0] = H"01";
		ENA_L1_TIME_COUNTER = VCC; -- abilito L1 timer
		IF L1_FLAG AND (L1_TIME_COUNTER[8..0] < L1A_LATENCY[8..0]-2) THEN 
			SEQ_CONTROLLER_SM = L1_TIME_VIOLATION;
		ELSIF L1_TIME_COUNTER[8..0] > (L1A_LATENCY[8..0]+2) THEN
			SEQ_CONTROLLER_SM = L1_TIMEOUT_REJECT_1;
		ELSIF L2_FLAG AND (L1_TIME_COUNTER[8..0] < L1A_LATENCY[8..0]-2) THEN
			SEQ_CONTROLLER_SM = L1_MISSING;
		ELSIF L1_FLAG AND (L1_TIME_COUNTER[8..0] >= L1A_LATENCY[8..0]-2) AND (L1_TIME_COUNTER[8..0] <= (L1A_LATENCY[8..0]+2)) THEN
			SEQ_CONTROLLER_SM = L2_WAITING;
		ELSE
			SEQ_CONTROLLER_SM = L1_WAITING;
		END IF;
		
	WHEN L1_TIME_VIOLATION => -- L1 arriva prima del tempo atteso
		CTRL_STATE[7..0] = H"02";
		ENA_L1_TIME_COUNTER = GND; -- disabilito L1 timer 
		ENA_L2_TIMEOUT_COUNTER = VCC;
		SET_ERROR_BIT_9 = VCC; -- setto il relativo bit di errore
		SEQ_CONTROLLER_SM = L2_WAITING;
		
	WHEN L1_TIMEOUT_REJECT_1 => -- L1 non arriva nel tempo utile, l'evento e' scartato
		CTRL_STATE[7..0] = H"03";
		ENA_L1_TIME_COUNTER = GND; -- disabilito L1 timer
		ENA_L2_TIMEOUT_COUNTER = GND; -- disabilto L2 timer
		TTC_COM_RST = VCC; -- faccio il reset dei column e del busy
		SEQ_CONTROLLER_SM = L1_TIMEOUT_REJECT_2;
	
	WHEN L1_TIMEOUT_REJECT_2 => 
		CTRL_STATE[7..0] = H"04";
		CLRN_L1_TIME_COUNTER = GND; --resetto L1 timer
		CLRN_L2_TIMEOUT_COUNTER = GND;  -- resetto L2 timer 
		TTC_COM_RST = VCC;
		RESET_FLAG = VCC; -- -resetto i flag
		SEQ_CONTROLLER_SM = IDLE_SEQ_CONTROLLER;
		
	WHEN L1_MISSING => -- L2 arriva nella latency di L1 e quindi L1 non arriva
		CTRL_STATE[7..0] = H"05";
		ENA_L1_TIME_COUNTER = GND; -- disabilito L1 timer 
		CLRN_L1_TIME_COUNTER = GND; -- resetto L1 timer
		CLRN_L2_TIMEOUT_COUNTER = GND;  -- resetto L2 timer
		SET_ERROR_BIT_10 = VCC; -- setto il relativo bit di errore: L2 timing violation
		SET_ERROR_BIT_13 = VCC; -- setto il relativo bit di errore: L1 missing
		IF L2a_FLAG THEN 
			SEQ_CONTROLLER_SM = L2a_SEND_1; 
		ELSE 
			SEQ_CONTROLLER_SM = L2r_SEND_1;
		END IF;		
		
	WHEN L2_WAITING => 
		CTRL_STATE[7..0] = H"06";
		ENA_L1_TIME_COUNTER = GND; -- disabilito L1 timer
		CLRN_L1_TIME_COUNTER = GND; -- resetto L1 timer
		ENA_L2_TIMEOUT_COUNTER = VCC; 
		SET_ERROR_BIT_9 = GND; -- da L1_TIME_VIOLATION dove � stato forzato a VCC
		SET_ERROR_BIT_1 = GND; -- da L0_MISSING dove � stato forzato a VCC
		IF L2_FLAG AND (L2_TIMEOUT_COUNTER[16..0] < H"0C80") THEN
			SEQ_CONTROLLER_SM = L2_TIMEOUT_VIOLATION;	
		ELSIF L2a_FLAG AND (L2_TIMEOUT_COUNTER[16..0] >= H"0C80") AND (L2_TIMEOUT_COUNTER[16..0] <= H"1B580") THEN    
			SEQ_CONTROLLER_SM = L2a_SEND_1; 
		ELSIF L2r_FLAG AND (L2_TIMEOUT_COUNTER[16..0] >= H"0C80") AND (L2_TIMEOUT_COUNTER[16..0] <= H"1B580") THEN    
			SEQ_CONTROLLER_SM = L2r_SEND_1; 
		ELSIF (L2_TIMEOUT_COUNTER[16..0] > H"1B580") THEN
			SEQ_CONTROLLER_SM = L2_MISSING_1; 
		ELSE
			SEQ_CONTROLLER_SM = L2_WAITING;
		END IF;				
	
	WHEN L2a_SEND_1 => -- generazione di un L2_PULSE per invio CDH e dati
		CTRL_STATE[7..0] = H"07";
		CLRN_L1_TIME_COUNTER = VCC;
		ENA_L2_TIMEOUT_COUNTER = GND; -- disabilito L2 timer
		CLRN_L2_TIMEOUT_COUNTER = GND; -- resetto L2 timer 
		SET_ERROR_BIT_10 = GND; -- da L1_MISSING dove � stato forzato a VCC
		SET_ERROR_BIT_13 = GND; -- da L1_MISSING o da L0_L1_MISSING dove � stato forzato a VCC
		SET_ERROR_BIT_1 = GND; -- da L0_L1_MISSING dove � stato forzato a VCC
		IF (SEND_L2 AND !ERROR_BIT_1) THEN 
			SEQ_CONTROLLER_SM = L2a_SEND_2;
		ELSIF (SEND_L2 AND ERROR_BIT_1) THEN
			SEQ_CONTROLLER_SM = L2a_SEND_1a;
		ELSE 
			SEQ_CONTROLLER_SM = L2a_SEND_1;
		END IF;
		
	WHEN L2a_SEND_1a => -- ho un L2a dopo un L1 senza avere ricevuto alcun L0, oppure il solo L2a senza L0 e L1 
		CTRL_STATE[7..0] = H"08";
		SET_SEQ_ERR_FLAG = VCC;
		SEQ_CONTROLLER_SM = L2a_SEND_2;	
		
	WHEN L2a_SEND_2 => -- L2 arriva nel tempo atteso, la sequenza si e' completata con successo
		CTRL_STATE[7..0] = H"09";
		SET_SEQ_ERR_FLAG = GND;
		CLRN_L2_TIMEOUT_COUNTER = VCC;
		RESET_FLAG = VCC; -- resetto i flag
		RES_SEND_L2 = VCC;
		L2_PULSE = VCC;
		SEQ_CONTROLLER_SM = L2a_SEND_3;
		
	WHEN L2a_SEND_3 => -- L2 arriva nel tempo atteso, la sequenza si e' completata con successo
		CTRL_STATE[7..0] = H"0A";
		RESET_FLAG = VCC; -- resetto i flag
		RES_SEND_L2 = VCC;
		L2_PULSE = VCC;
		SEQ_CONTROLLER_SM = IDLE_SEQ_CONTROLLER;
		
	WHEN L2r_SEND_1 => -- reset dei segment e del busy interno; nel caso di errore si ha cmq la generazione di un L2_PULSE per l'invio del solo CDH 
		CTRL_STATE[7..0] = H"0B";
		CLRN_L1_TIME_COUNTER = VCC;
		ENA_L2_TIMEOUT_COUNTER = GND; -- disabilito L2 timer
		CLRN_L2_TIMEOUT_COUNTER = GND; -- resetto L2 timer
		SET_ERROR_BIT_10 = GND; -- da L1_MISSING dove � stato forzato a VCC
		SET_ERROR_BIT_13 = GND; -- da L1_MISSING o da L0_L1_MISSING dove � stato forzato a VCC
		SET_ERROR_BIT_1 = GND; -- da L0_L1_MISSING dove � stato forzato a VCC
		TTC_COM_RST = VCC; -- reset dei segment e del busy interno 
		IF (ERROR_BIT_10 OR ERROR_BIT_9 OR ERROR_BIT_1 OR ERROR_BIT_0) THEN 
			SEQ_CONTROLLER_SM = L2r_SEND_2a; 
		ELSE 
			SEQ_CONTROLLER_SM = L2r_SEND_2;					-- se ha errore deve cmq inviare il solo CDH
		END IF;
		
	WHEN L2r_SEND_2 => 
		CTRL_STATE[7..0] = H"0C";
		CLRN_L2_TIMEOUT_COUNTER = VCC; 
		TTC_COM_RST = VCC;
		SEQ_CONTROLLER_SM = L2r_SEND_3;
		
	WHEN L2r_SEND_3 => 
		CTRL_STATE[7..0] = H"0D";
		RESET_FLAG = VCC; -- resetto i flag
		TTC_COM_RST = VCC;
		SEQ_CONTROLLER_SM = IDLE_SEQ_CONTROLLER;		
		
	WHEN L2r_SEND_2a => 
		CTRL_STATE[7..0] = H"0E";
		CLRN_L2_TIMEOUT_COUNTER = VCC; 
		TTC_COM_RST = VCC;
		SET_SEQ_ERR_FLAG = VCC;
		SEQ_CONTROLLER_SM = L2r_SEND_3a;	
		
	WHEN L2r_SEND_3a => 
		CTRL_STATE[7..0] = H"0F";
		TTC_COM_RST = VCC;
		SET_SEQ_ERR_FLAG = GND;
		L2_PULSE = VCC;
		SEQ_CONTROLLER_SM = L2r_SEND_4a;	
		
	WHEN L2r_SEND_4a => 
		CTRL_STATE[7..0] = H"10";
		TTC_COM_RST = VCC;
		L2_PULSE = VCC;
		RESET_FLAG = VCC;	
		SEQ_CONTROLLER_SM = IDLE_SEQ_CONTROLLER;		
		
	WHEN L2_TIMEOUT_VIOLATION => -- L2 e' arrivato prima della acceptance window attesa 
		CTRL_STATE[7..0] = H"11";
		CLRN_L1_TIME_COUNTER = VCC;
		ENA_L2_TIMEOUT_COUNTER = GND; -- disabilito L2 timer
		CLRN_L2_TIMEOUT_COUNTER = GND;  -- resetto L2 timer
		SET_ERROR_BIT_10 = VCC; -- setto il relativo bit di errore 
		IF L2a_FLAG THEN 
			SEQ_CONTROLLER_SM = L2a_SEND_1; -- era L2_SEQ_OK 
		ELSE 
			SEQ_CONTROLLER_SM = L2r_SEND_1;			
		END IF;
		
	WHEN L2_MISSING_1 => -- L2 non e' arrivato nel tempo atteso 
		CTRL_STATE[7..0] = H"12";
		CLRN_L1_TIME_COUNTER = VCC;
		ENA_L2_TIMEOUT_COUNTER = GND; -- disabilito L2 timer
		CLRN_L2_TIMEOUT_COUNTER = GND;  -- resetto L2 timer
		SET_ERROR_BIT_10 = VCC; -- setto il relativo bit di errore 
		SET_SEQ_ERR_FLAG = VCC; -- setto il flag che indica alla ddl_ctrlrl di inviare il solo CDH e alla DECODER_SM di generare un L2_PULSE
		SEQ_CONTROLLER_SM = L2_MISSING_2; 
		
	WHEN L2_MISSING_2 => 
		CTRL_STATE[7..0] = H"13";
		CLRN_L2_TIMEOUT_COUNTER = VCC; 
		SET_ERROR_BIT_10 = GND;
		SET_SEQ_ERR_FLAG = GND;
		L2_PULSE = VCC; -- invio L2 pulse per l'invio del solo header
		TTC_COM_RST = VCC; -- faccio il reset dell'elettronica e della logica interna di busy
		SEQ_CONTROLLER_SM = L2_MISSING_3;
		
	WHEN L2_MISSING_3 =>
		CTRL_STATE[7..0] = H"14";
		L2_PULSE = VCC;
		TTC_COM_RST = VCC;
		RESET_FLAG = VCC; -- resetto i flag		
		SEQ_CONTROLLER_SM = IDLE_SEQ_CONTROLLER;	
		
	WHEN L0_MISSING => 
		CTRL_STATE[7..0] = H"15";
		ENA_L2_TIMEOUT_COUNTER = VCC; -- abilito L2 timer 
		SET_ERROR_BIT_1 = VCC;
		SEQ_CONTROLLER_SM = L2_WAITING;	
		
	WHEN L0_L1_MISSING => 
		CTRL_STATE[7..0] = H"16";
		SET_ERROR_BIT_13 = VCC;
		IF L2a_FLAG THEN 
			SEQ_CONTROLLER_SM = L2a_SEND_1;
		ELSE 
			SEQ_CONTROLLER_SM = L2r_SEND_1;
		END IF;	
		
	WHEN OTHERS =>
		SEQ_CONTROLLER_SM = IDLE_SEQ_CONTROLLER;
		
END CASE;	
	

END;
